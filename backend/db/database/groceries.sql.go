// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: groceries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countGroceries = `-- name: CountGroceries :one
SELECT COUNT(*) 
FROM grocery_items
WHERE 
  (($2::boolean = TRUE AND deleted_at IS NOT NULL) OR ($2 = FALSE AND deleted_at IS NULL) OR $2 IS NULL)
  AND (
    ($1::boolean IS NULL AND bought_at IS NULL)
    OR ($1 = TRUE AND bought_at IS NOT NULL)
    OR ($1 = FALSE AND bought_at IS NULL)
  )
`

type CountGroceriesParams struct {
	Column1 bool
	Column2 bool
}

func (q *Queries) CountGroceries(ctx context.Context, arg CountGroceriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countGroceries, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGrocery = `-- name: CreateGrocery :one
INSERT INTO grocery_items(
	name)
	VALUES ($1)
RETURNING id, name, created_at, deleted_at, bought_at, updated_at
`

func (q *Queries) CreateGrocery(ctx context.Context, name pgtype.Text) (GroceryItem, error) {
	row := q.db.QueryRow(ctx, createGrocery, name)
	var i GroceryItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.BoughtAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroceries = `-- name: GetGroceries :many
SELECT id, name, created_at, deleted_at, bought_at, updated_at 
FROM grocery_items
WHERE 
  (($4::boolean = TRUE AND deleted_at IS NOT NULL) OR ($4 = FALSE AND deleted_at IS NULL) OR $4 IS NULL)
  AND (
    ($1::boolean IS NULL AND bought_at IS NULL)
    OR ($1 = TRUE AND bought_at IS NOT NULL)
    OR ($1 = FALSE AND bought_at IS NULL)
  )
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetGroceriesParams struct {
	Column1 bool
	Limit   int32
	Offset  int32
	Column4 bool
}

func (q *Queries) GetGroceries(ctx context.Context, arg GetGroceriesParams) ([]GroceryItem, error) {
	rows, err := q.db.Query(ctx, getGroceries,
		arg.Column1,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroceryItem
	for rows.Next() {
		var i GroceryItem
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.BoughtAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toBuy = `-- name: ToBuy :exec
UPDATE grocery_items
SET 
  bought_at = $1
WHERE id = $2
`

type ToBuyParams struct {
	BoughtAt pgtype.Timestamp
	ID       pgtype.UUID
}

func (q *Queries) ToBuy(ctx context.Context, arg ToBuyParams) error {
	_, err := q.db.Exec(ctx, toBuy, arg.BoughtAt, arg.ID)
	return err
}

const toDelete = `-- name: ToDelete :exec
UPDATE grocery_items
SET 
  deleted_at = $1
WHERE id = $2
`

type ToDeleteParams struct {
	DeletedAt pgtype.Timestamp
	ID        pgtype.UUID
}

func (q *Queries) ToDelete(ctx context.Context, arg ToDeleteParams) error {
	_, err := q.db.Exec(ctx, toDelete, arg.DeletedAt, arg.ID)
	return err
}

const toRestore = `-- name: ToRestore :exec
UPDATE grocery_items
SET 
  bought_at = null
WHERE id = $1
`

func (q *Queries) ToRestore(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, toRestore, id)
	return err
}

const updateGrocery = `-- name: UpdateGrocery :exec
UPDATE grocery_items
SET 
  name = $1
WHERE id = $2
`

type UpdateGroceryParams struct {
	Name pgtype.Text
	ID   pgtype.UUID
}

func (q *Queries) UpdateGrocery(ctx context.Context, arg UpdateGroceryParams) error {
	_, err := q.db.Exec(ctx, updateGrocery, arg.Name, arg.ID)
	return err
}
